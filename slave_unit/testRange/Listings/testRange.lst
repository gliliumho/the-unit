C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TESTRANGE
OBJECT MODULE PLACED IN .\Objects\testRange.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE testRange.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\testRange.lst) TABS(2) OBJECT(.\Objects\testRange.obj)

line level    source

   1          
   2          #include <Nordic\reg9e5.h>
   3          
   4          #define HFREQ 0   // 0=433MHz, 1=868/915MHz
   5          #define POWER 3   // 0=min power...3 = max power
   6          
   7          void InitPin(unsigned char pinNum, direction){
   8   1        switch(pinNum){
   9   2          case 0:
  10   2            P0_ALT &= 0xFE;
  11   2            if (direction == 1) P0_DIR |= 0x01;
  12   2            else P0_DIR &= 0xFE;
  13   2            break;
  14   2          
  15   2          case 1:
  16   2            P0_ALT &= 0xFD;
  17   2            if (direction == 1) P0_DIR |= 0x02;
  18   2            else P0_DIR &= 0xFD;
  19   2            break;
  20   2          
  21   2          case 2:
  22   2            P0_ALT &= 0xFB;
  23   2            if (direction == 1) P0_DIR |= 0x04;
  24   2            else P0_DIR &= 0xFB;
  25   2            break;
  26   2            
  27   2          case 3:
  28   2            P0_ALT &= 0xF7;
  29   2            if (direction == 1) P0_DIR |= 0x08;
  30   2            else P0_DIR &= 0xF7;
  31   2            break;
  32   2          
  33   2          case 4:
  34   2            P0_ALT &= 0xEF;
  35   2            if (direction == 1) P0_DIR |= 0x10;
  36   2            else P0_DIR &= 0xEF;
  37   2            break;
  38   2          
  39   2          case 5:
  40   2            P0_ALT &= 0xDF;
  41   2            if (direction == 1) P0_DIR |= 0x20;
  42   2            else P0_DIR &= 0xDF;
  43   2            break;
  44   2          
  45   2          case 6:
  46   2            P0_ALT &= 0xBF;
  47   2            if (direction == 1) P0_DIR |= 0x40;
  48   2            else P0_DIR &= 0xBF;
  49   2            break;
  50   2            
  51   2          case 7:
  52   2            P0_ALT &= 0x7F;
  53   2            if (direction == 1) P0_DIR |= 0x80;
  54   2            else P0_DIR &= 0x7F;
C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 2   

  55   2            break;  
  56   2            
  57   2          case 8:
  58   2            P0_ALT = 0x00;
  59   2            if (direction == 1) P0_DIR = 0xFF;
  60   2            else P0_DIR = 0x00;
  61   2            break;
  62   2            
  63   2          default:
  64   2            break;
  65   2            
  66   2        }
  67   1      
  68   1      }
  69          
  70          /* ---SetTXPower() & SetFrequency()------------------------
  71          ---------------------------------------------
  72          Currently not used and not working. 
  73          ---------------------------------------------
  74          void SetTXPower(unsigned char powerlevel){
  75            switch(powerlevel){
  76              case 0:
  77                CC &= 0xF3FF;
  78                break;
  79              case 1:
  80                CC &= 0xF7FF;
  81                CC |= 0x0400;
  82                break;
  83              case 2:
  84                CC &= 0xFBFF;
  85                CC |= 0x0800;
  86                break;
  87              case 3:
  88                CC |= 0x0C00;
  89                break;
  90            }
  91          }
  92          
  93          
  94          ------------------------------------------
  95          Currently not used and not working. 
  96          ------------------------------------------
  97          void SetFrequency(unsigned char freq){
  98            if(freq == 1)
  99              CC |= 0x0200;
 100            else
 101              CC &= 0xFDFF;
 102          } 
 103          */
 104          
 105          
 106          void Delay400us(volatile unsigned char n){
 107   1        unsigned char i;
 108   1        while(n--)
 109   1          for(i=0;i<35;i++)
 110   1            ;
 111   1      }
 112          
 113          void Delay5ms(volatile unsigned char n){
 114   1        while(n--)
 115   1          Delay400us(50);
 116   1      }
C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 3   

 117          
 118          unsigned char SpiReadWrite(unsigned char b){
 119   1        EXIF &= ~0x20;          // Clear SPI interrupt
 120   1        SPI_DATA = b;           // Move byte to send to SPI data register
 121   1        while((EXIF & 0x20) == 0x00)  // Wait until SPI has finished transmitting
 122   1          ;
 123   1        return SPI_DATA;
 124   1      }
 125          
 126          void TransmitPacket(unsigned char b){
 127   1        RACSN = 0;
 128   1        SpiReadWrite(WTP);
 129   1        SpiReadWrite(b);
 130   1        RACSN = 1;
 131   1        TRX_CE = 1;
 132   1        Delay400us(1);
 133   1        TRX_CE = 0;
 134   1      }
 135          
 136          unsigned char ReceivePacket(void){
 137   1        unsigned char b;
 138   1      
 139   1        TRX_CE = 1;
 140   1      
 141   1        while(DR == 0)
 142   1          ;
 143   1        RACSN = 0;
 144   1        SpiReadWrite(RRP);
 145   1        b = SpiReadWrite(0);
 146   1        RACSN = 1;
 147   1        TRX_CE = 0;
 148   1        return b;
 149   1      }
 150          
 151          void InitUART(void){
 152   1        
 153   1        unsigned char cklf;
 154   1        
 155   1        TH1 = 0xE6;           // 9600@16MHz (when T1M=1 and SMOD=1)
 156   1        CKCON |= 0x10;          // T1M=1 (/4 timer clock)
 157   1        PCON = 0x80;          // SMOD=1 (double baud rate)
 158   1        SCON = 0x52;          // Serial mode1, enable receiver
 159   1        TMOD = 0x20;          // Timer1 8bit auto reload 
 160   1        TR1 = 1;            // Start timer1
 161   1        P0_ALT |= 0x06; //select alternative function for P01 and P02
 162   1        P0_DIR &= 0x02; //P01(RXD) is input
 163   1        
 164   1        SPICLK = 0;     //Max SPI clock
 165   1        SPI_CTRL = 0x02;
 166   1        
 167   1        // Switch to 16MHz clock:
 168   1        RACSN = 0;
 169   1        SpiReadWrite(RRC | 0x09);
 170   1        cklf = SpiReadWrite(0) | 0x04;  //XO_DIRECT = 1, follow XO_Frequency
 171   1        RACSN = 1;
 172   1        RACSN = 0;
 173   1        SpiReadWrite(WRC | 0x09);
 174   1        SpiReadWrite(cklf);
 175   1        RACSN = 1;
 176   1      }
 177          
 178          void PutChar(unsigned char c){
C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 4   

 179   1        while(!TI)
 180   1          ;
 181   1        TI = 0;
 182   1        SBUF = c;
 183   1      }
 184          
 185          void PutString(unsigned char *s){
 186   1        while(*s != 0)
 187   1          PutChar(*s++);
 188   1      }
 189          
 190          void GetChar(unsigned char *c){
 191   1        while(!RI)
 192   1          ;
 193   1        RI=0;
 194   1        *c = SBUF;
 195   1      }
 196          
 197          void GetString(unsigned char *s){
 198   1        GetChar(s);
 199   1        while(*s!= 0x0D && *s!= 0x0A){  //GetChar as long as not ENTER.
 200   2          s++;
 201   2          GetChar(s);
 202   2        }
 203   1        *s = 0;
 204   1      }
 205          
 206          void PrintNumber(unsigned int n){
 207   1        unsigned char bit4, bit3, bit2, bit1, bit0;
 208   1        
 209   1        if(n >= 10000){
 210   2          bit4 = n/10000;
 211   2          n -= bit4*10000;
 212   2        } else{
 213   2          bit4 = 0;
 214   2        }
 215   1        
 216   1        if(n >= 1000){
 217   2          bit3 = n/1000;
 218   2          n -= bit3*1000;
 219   2        } else{
 220   2          bit3 = 0;
 221   2        }
 222   1        
 223   1        if(n >= 100){
 224   2          bit2 = n/100;
 225   2          n -= bit2*100;
 226   2        } else{
 227   2          bit2 = 0;
 228   2        }
 229   1        
 230   1        if(n >= 10){
 231   2          bit1 = n/10;
 232   2          n -= bit1*10;
 233   2        } else{
 234   2          bit1 = 0;
 235   2        }
 236   1        
 237   1        bit0 = n;
 238   1        
 239   1        
 240   1        bit4 += 0x30;
C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 5   

 241   1        bit3 += 0x30;
 242   1        bit2 += 0x30;
 243   1        bit1 += 0x30;
 244   1        bit0 += 0x30;
 245   1        
 246   1        if(bit4 >= 0x31){
 247   2          PutChar(bit4);
 248   2          PutChar(bit3);
 249   2          PutChar(bit2);
 250   2          PutChar(bit1);
 251   2        }else if(bit3 >= 0x31){
 252   2          PutChar(bit3);
 253   2          PutChar(bit2);
 254   2          PutChar(bit1);
 255   2        }else if(bit2 >= 0x31){
 256   2          PutChar(bit2);
 257   2          PutChar(bit1);
 258   2        }else if(bit1>= 0x31)
 259   1          PutChar(bit1);
 260   1        
 261   1        PutChar(bit0);
 262   1      
 263   1      }
 264          void ConsoleComment(void){
 265   1        unsigned char c = 0x00;
 266   1        
 267   1        GetChar(&c);
 268   1        while(c!=0x0D && c!=0x0A){
 269   2          PutChar(c);
 270   2          GetChar(&c);
 271   2        }
 272   1        PutString("\r\nDone!\r\n");
 273   1      }
 274          
 275          void SetAutoRetransmit(unsigned char setting){
 276   1        
 277   1        unsigned char tmp;
 278   1        
 279   1        RACSN = 0;
 280   1        SpiReadWrite(RRC | 0x01);       //Read RF config address byte #1
 281   1        tmp = SpiReadWrite(0) & 0xDF;   //store current RF config and clear off AUTORETRAN bit
 282   1        RACSN = 1;
 283   1        
 284   1        RACSN = 0;
 285   1        SpiReadWrite(WRC | 0x01);     //Write RF config at addr byte #1
 286   1        SpiReadWrite(tmp | (setting <<5));  //change the AUTORETRAN setting
 287   1        RACSN = 1;
 288   1      }
 289          
 290          void InitRF(void){
 291   1        
 292   1        unsigned char tmp;
 293   1        
 294   1        SPICLK = 0;           //Max SPI clock
 295   1        SPI_CTRL = 0x02;
 296   1        
 297   1        //Configure RF
 298   1        RACSN = 0;
 299   1        SpiReadWrite(WRC | 0x03);    // Write to RF config address 3 (RX payload)
 300   1        SpiReadWrite(0x01);      // One byte RX payload width
 301   1        SpiReadWrite(0x01);      // One byte TX payload width
 302   1        RACSN = 1;
C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 6   

 303   1      
 304   1        RACSN = 0;
 305   1        SpiReadWrite(RRC | 0x01);    // Read RF config address 1
 306   1        tmp = SpiReadWrite(0) & 0xf1;   // Clear the power and frequency setting bits
 307   1        RACSN = 1;
 308   1      
 309   1        RACSN = 0;
 310   1        SpiReadWrite(WRC | 0x01);   // Write RF config address 1
 311   1        // Change power defined by POWER and to 433 or 868/915MHz defined by HFREQ above:
 312   1        SpiReadWrite(tmp | (POWER <<2) | (HFREQ << 1));
 313   1        RACSN = 1;
 314   1        
 315   1      }
 316          
 317          
 318          void Transmitter(void){
 319   1        unsigned char i,j,n = 0x00;
 320   1        TXEN = 1;
 321   1        
 322   1        while(1){
 323   2          if(P03 == 0){
 324   3            
 325   3            for(i=0;i<50;i++){
 326   4              TransmitPacket(0x01);
 327   4              Delay400us(5);
 328   4              TransmitPacket(n);
 329   4              P00 ^= 1;
 330   4            }
 331   3            
 332   3            Delay5ms(10);
 333   3            P00 = 0;
 334   3            
 335   3            for(i=0x61; i<=0x74; i++){
 336   4              TransmitPacket(i);
 337   4              P00 ^= 1;
 338   4              Delay5ms(10);   //delay 0.10s
 339   4              for(j=0x31; j<=0x39; j++){
 340   5                //PutString("Transmitting letter: ");
 341   5                //PutChar(letter);
 342   5                //PutString("\r\n");
 343   5                TransmitPacket(j);
 344   5                P00 ^= 1;
 345   5                Delay5ms(10);   //delay 0.15s
 346   5              }
 347   4            }
 348   3            
 349   3            for(i=0;i<100;i++){
 350   4              TransmitPacket(0x04);
 351   4              P00 ^= 1;
 352   4              Delay400us(5);
 353   4            }
 354   3            
 355   3            n++;
 356   3            if (n > 0x09)
 357   3              n = 0x00;
 358   3            P00 = 1;
 359   3          }
 360   2                
 361   2        }
 362   1      }
 363          
 364          void Receiver(void){
C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 7   

 365   1        unsigned char letter = 0x00;
 366   1        unsigned char headerFlag = 0;
 367   1        unsigned char endFlag = 1;
 368   1        unsigned int packetCount = 0;
 369   1        TXEN = 0;
 370   1        
 371   1        PutString("\r\n \r\nReceiver started.");
 372   1        
 373   1        while(1){ 
 374   2          letter = ReceivePacket(); 
 375   2          
 376   2          if(((letter >= 0x30 && letter <= 0x39)||(letter>=0x61 && letter<=0x7A)) && endFlag==0){ 
 377   3            //if letter is 0-9 or a-z
 378   3            headerFlag = 0;
 379   3            P00 = 0;  //Turn on LED1
 380   3            
 381   3            //if letter is a-z, print new line
 382   3            if(letter>=0x61 && letter<=0x7A)
 383   3              PutString("\r\n");
 384   3            
 385   3            packetCount++;
 386   3            PutChar(letter);
 387   3            letter = 0x00;
 388   3          } else if(letter == 0x01 && headerFlag == 0){ //to indicate transmitter just started
 389   3            letter = ReceivePacket();
 390   3            PutString("\r\n \r\nNew Transmission:");
 391   3            letter += 0x30;
 392   3            PutChar(letter);
 393   3            headerFlag = 1;
 394   3            endFlag = 0;
 395   3            packetCount = 0;
 396   3          } else if(letter == 0x04 && endFlag == 0){  //to indicate end of transmission
 397   3            headerFlag = 0;
 398   3            endFlag = 1;
 399   3            PutString("\r\nEnd of Transmission. Received ");
 400   3            PrintNumber(packetCount);
 401   3            PutString("/200 packets sent. Packet loss: ");
 402   3            packetCount = (200-packetCount)*100/200;
 403   3            PrintNumber(packetCount);
 404   3            PutChar(0x25);
 405   3            packetCount = 0;
 406   3            PutString("\r\nEnter Comment: ");
 407   3            ConsoleComment();
 408   3          }
 409   2        }
 410   1        
 411   1      }
 412          
 413          void main(){
 414   1        
 415   1        InitPin(0,0); //Initialize P00 for LED1
 416   1        InitPin(3,1);
 417   1        InitPin(5,1);
 418   1        
 419   1        P00 = 1;    //Initialize with LED1 turned OFF
 420   1        
 421   1        InitUART();
 422   1        InitRF();
 423   1        
 424   1        if(P03 == 0){
 425   2          Transmitter();
 426   2        } else if (P05 == 0){
C51 COMPILER V9.54   TESTRANGE                                                             08/06/2015 11:37:27 PAGE 8   

 427   2          Receiver();
 428   2        }
 429   1        
 430   1      }
 431          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1250    ----
   CONSTANT SIZE    =    143    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
